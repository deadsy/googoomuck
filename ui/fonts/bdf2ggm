#!/usr/bin/env python
#------------------------------------------------------------------------------
"""
convert a BDF font file to GGM C file form
"""
#------------------------------------------------------------------------------

import getopt
import sys
import os

#------------------------------------------------------------------------------

_ifile = None
_ofile = None

#------------------------------------------------------------------------------

def print_usage(argv):
  print('Usage: %s [options]' % argv[0])
  print('Options:')
  print('%-18s%s' % ('-i <input_file>', 'input file'))
  print('%-18s%s' % ('-o <output_file>', 'output file'))

def error(msg, usage = False):
  print('error: %s' % msg)
  if usage:
    print_usage(sys.argv)
  sys.exit(1)

def warning(msg, fname = True):
  if fname:
    print('%s: warning: %s' % (_ifile, msg))
  else:
    print('warning: %s' % msg)

def process_options(argv):
  """process command line options"""
  global _ifile, _ofile
  try:
    (opts, args) = getopt.getopt(sys.argv[1:], "i:o:")
  except getopt.GetoptError as err:
    error(str(err), True)
  if args:
    error('invalid arguments on command line', True)
  for (opt, val) in opts:
    if opt == '-i':
      _ifile = val
    if opt == '-o':
      _ofile = val

  if not _ifile:
    error('specify an input file', True)

  if not _ofile:
    name =  os.path.split(_ifile)[1].split('.')[0]
    _ofile =  '%s.c' % name

#------------------------------------------------------------------------------

class glyph(object):

  def __init__(self, name):
    self.name = name
    self.encoding = None
    self.bb_w = None
    self.bb_h = None
    self.bb_xofs = None
    self.bb_yofs = None
    self.dwidth_x = None
    self.dwidth_y = None
    self.bitmap = 0;

  def encode_bitmap(self):
    return 'static const uint32_t %s[] = {};' % self.name

  def encode_meta(self):
    s = []
    s.append('%d,%d,%d,%d,%d' % (self.bb_w, self.bb_h, self.bb_xofs, self.bb_yofs, self.dwidth_x))
    s.append(self.name)
    return '{%s}, // 0x%02x' % (','.join(s), self.encoding)


#------------------------------------------------------------------------------

class font(object):

  def __init__(self, fname):
    self.name = None
    self.current_glyph = None
    self.hex_to_get = None
    self.properties = {}
    self.glyphs = {}
    # read the file
    f = open(fname, 'r')
    lines = f.readlines()
    f.close
    lines = [l.strip() for l in lines]
    # parse the file
    self.parse_bdf(lines)

  def parse_startfont(self, l, n):
    if l[0] == 'STARTFONT' and l[1] == '2.1':
      return 'global'
    return 'startfont'

  def parse_global(self, l, n):
    if l[0] == 'FONT':
      self.name = l[1].lower()
    elif l[0] == 'SIZE':
      pass
    elif l[0] == 'FONTBOUNDINGBOX':
      pass
    elif l[0] == 'STARTPROPERTIES':
      return 'properties'
    elif l[0] == 'CHARS':
      return 'chars'
    else:
      error('unknown global element %s' % l[0])
    return 'global'

  def parse_properties(self, l, n):
    if l[0] == 'ENDPROPERTIES':
      return 'global'
    else:
      self.properties[l[0]] = l[1]
    return 'properties'

  def parse_char(self, l, n):
    if l[0] == 'ENCODING':
      self.current_glyph.encoding = int(l[1])
    elif l[0] == 'SWIDTH':
      pass
    elif l[0] == 'DWIDTH':
      x = l[1].split()
      if len(x) != 2:
        error('wrong number of DWIDTH parameters at line %d' % n)
      self.current_glyph.dwidth_x = int(x[0])
      self.current_glyph.dwidth_y = int(x[1])
    elif l[0] == 'BBX':
      x = l[1].split()
      if len(x) != 4:
        error('wrong number of BBX parameters at line %d' % n)
      self.current_glyph.bb_w = int(x[0])
      self.current_glyph.bb_h = int(x[1])
      self.current_glyph.bb_xofs = int(x[2])
      self.current_glyph.bb_yofs = int(x[3])
    elif l[0] == 'BITMAP':
      if self.current_glyph.bb_h:
        self.hex_to_get = self.current_glyph.bb_h
        return 'bitmap'
    elif l[0] == 'ENDCHAR':
      self.current_glyph = None
      return 'chars'
    else:
      error ('unknown char field %s at line %d' % (l[0], n))
    return 'char'

  def parse_chars(self, l, n):
    if l[0] == 'STARTCHAR':
      if self.current_glyph is None:
        name = '%s_%s' % (self.name, l[1])
        self.glyphs[name] = glyph(name)
        self.current_glyph = self.glyphs[name]
        return 'char'
      else:
        error ('need an ENDCHAR before the STARTCHAR at line %d' % n)
    return 'chars'

  def parse_bitmap(self, l, n):
    self.hex_to_get -= 1
    if self.hex_to_get == 0:
      return 'char'
    return 'bitmap'

  def parse_bdf(self, lines):
    state = 'startfont'
    for i in range(len(lines)):
      if lines[i].startswith('COMMENT'):
        continue
      l = lines[i].split(' ', 1)
      n = i + 1
      if state == 'startfont':
        state = self.parse_startfont(l, n)
      elif state == 'global':
        state = self.parse_global(l, n)
      elif state == 'properties':
        state = self.parse_properties(l, n)
      elif state == 'chars':
        state = self.parse_chars(l, n)
      elif state == 'char':
        state = self.parse_char(l, n)
      elif state == 'bitmap':
        state = self.parse_bitmap(l, n)
      else:
        error('bad state %s' % state)

  def max_ascent(self):
    if self.properties.has_key('FONT_ASCENT'):
      return int(self.properties['FONT_ASCENT'])
    assert False, 'TODO: work out max font ascent'

  def max_descent(self):
    if self.properties.has_key('FONT_DESCENT'):
      return -int(self.properties['FONT_DESCENT'])
    assert False, 'TODO: work out max font descent'

  def encode_preamble(self):
    s = []
    s.append("// generated by: %s (don't edit)" % ' '.join(sys.argv))
    if self.properties.has_key('COPYRIGHT'):
      s.append('// Copyright: %s' % self.properties['COPYRIGHT'])
    s.append('#include "lcd.h"')
    return '\n'.join(s)

  def encode_bitmaps(self):
    # sort the glyphs by encoding
    l = [(v.encoding, v) for v in self.glyphs.values()]
    l.sort()
    s = []
    for _, v in l:
      s.append(v.encode_bitmap())
    return '\n'.join(s)

  def encode_font(self):
    # sort the glyphs by encoding
    l = [(v.encoding, v) for v in self.glyphs.values()]
    l.sort()
    s = []
    s.append('const struct font %s = {' % self.name)
    s.append('  .ascent = %d,' % self.max_ascent())
    s.append('  .descent = %d,' % self.max_descent())
    s.append('  .glyphs = {')
    for _, v in l:
      s.append('    %s' % v.encode_meta())
    s.append('  }, ')
    s.append('};')
    return '\n'.join(s)

  def encode_ggm(self):
    s = []
    s.append(self.encode_preamble())
    s.append(self.encode_bitmaps())
    s.append(self.encode_font())
    return '\n'.join(s)

#------------------------------------------------------------------------------

def main():
  process_options(sys.argv)
  f = font(_ifile)
  print f.encode_ggm()

main()

#------------------------------------------------------------------------------
