//-----------------------------------------------------------------------------
/*

Goom Waves

A Goom Wave is a wave shape with the following segments:

1) A rising cos -pi to 0 curve (s0)
2) A flat piece at the top (f0)
3) A falling cos 0 to pi curve (s1)
4) A flat piece at the bottom (f1)

Shape is controller by two parameters:
duty = split the total period between s0,f0 and s1,f1
slope = split s0f0 and s1f1 beween slope and flat.

*/
//-----------------------------------------------------------------------------

#include <string.h>
#include <math.h>

#include "ggm.h"

#define DEBUG
#include "logging.h"

//-----------------------------------------------------------------------------

// N bits to represent the phase
#define PHASE_BITS (16U)
#define PHASE_MAX (1U << PHASE_BITS)

// This divisor maps the phase value onto the index used for the lookup table.
#define SLOPE_DIV (16U)

// Limit how close the duty cyle can get to 0/100%.
#define TP_MIN (PHASE_MAX >> 6)

// Limit how fast the slope can rise.
#define S_MIN 0.1f

// frequency to x scaling (xrange/fs)
#define GWAVE_FSCALE ((float)PHASE_MAX / AUDIO_FS)

//-----------------------------------------------------------------------------

// generated by ./scripts/lut.py
#define GWAVE_BITS (6U)
#define GWAVE_SIZE (1U << 6)
static const uint32_t GWAVE_data[GWAVE_SIZE] = {
	0xbf800000U, 0xbf7fae89U, 0xbf7eba56U, 0xbf7d2404U,
	0xbf7aec96U, 0xbf781573U, 0xbf74a06bU, 0xbf708fb2U,
	0xbf6be5ddU, 0xbf66a5e5U, 0xbf60d321U, 0xbf5a7145U,
	0xbf538462U, 0xbf4c10e0U, 0xbf441b7dU, 0xbf3ba94aU,
	0xbf32bfa6U, 0xbf29643eU, 0xbf1f9d07U, 0xbf15703aU,
	0xbf0ae450U, 0xbf000000U, 0xbee99471U, 0xbed29439U,
	0xbebb0dfbU, 0xbea310afU, 0xbe8aab9aU, 0xbe63dc87U,
	0xbe31d0d4U, 0xbdfea7eaU, 0xbd990c17U, 0xbccc3b73U,
	0x3ccc3b73U, 0x3d990c17U, 0x3dfea7eaU, 0x3e31d0d4U,
	0x3e63dc87U, 0x3e8aab9aU, 0x3ea310afU, 0x3ebb0dfbU,
	0x3ed29439U, 0x3ee99471U, 0x3f000000U, 0x3f0ae450U,
	0x3f15703aU, 0x3f1f9d07U, 0x3f29643eU, 0x3f32bfa6U,
	0x3f3ba94aU, 0x3f441b7dU, 0x3f4c10e0U, 0x3f538462U,
	0x3f5a7145U, 0x3f60d321U, 0x3f66a5e5U, 0x3f6be5ddU,
	0x3f708fb2U, 0x3f74a06bU, 0x3f781573U, 0x3f7aec96U,
	0x3f7d2404U, 0x3f7eba56U, 0x3f7fae89U, 0x3f800000U,
};

static const uint32_t GWAVE_DY_data[GWAVE_SIZE] = {
	0x3aa2eecdU, 0x3b74325bU, 0x3bcb28f1U, 0x3c0ddbb4U,
	0x3c35c8a6U, 0x3c5d41e5U, 0x3c821729U, 0x3c953a94U,
	0x3ca7ff04U, 0x3cba5889U, 0x3ccc3b73U, 0x3cdd9c62U,
	0x3cee7044U, 0x3cfeac65U, 0x3d072338U, 0x3d0e9a3bU,
	0x3d15b67bU, 0x3d1c7372U, 0x3d22ccd6U, 0x3d28be9dU,
	0x3d2e44feU, 0x3d335c74U, 0x3d3801c3U, 0x3d3c31f5U,
	0x3d3fea5fU, 0x3d4328a5U, 0x3d45eab4U, 0x3d482ecdU,
	0x3d49f37dU, 0x3d4b37a4U, 0x3d4bfa75U, 0x3d4c3b73U,
	0x3d4bfa75U, 0x3d4b37a4U, 0x3d49f37dU, 0x3d482ecdU,
	0x3d45eab4U, 0x3d4328a5U, 0x3d3fea5fU, 0x3d3c31f5U,
	0x3d3801c3U, 0x3d335c74U, 0x3d2e44feU, 0x3d28be9dU,
	0x3d22ccd6U, 0x3d1c7372U, 0x3d15b67bU, 0x3d0e9a3bU,
	0x3d072338U, 0x3cfeac65U, 0x3cee7044U, 0x3cdd9c62U,
	0x3ccc3b73U, 0x3cba5889U, 0x3ca7ff04U, 0x3c953a94U,
	0x3c821729U, 0x3c5d41e5U, 0x3c35c8a6U, 0x3c0ddbb4U,
	0x3bcb28f1U, 0x3b74325bU, 0x3aa2eecdU, 0x00000000U,
};

//-----------------------------------------------------------------------------

void gwave_gen(struct gwave *osc, float *out, size_t n) {
	unsigned int i;
	float y, dy, frac;

	for (i = 0; i < n; i++) {
		// what portion of the goom wave are we in?
		if (osc->x < osc->tp) {
			// we are in the s0/f0 portion
			uint32_t sx = osc->x * osc->k0;
			uint32_t idx = __USAT(sx >> SLOPE_DIV, GWAVE_BITS);
			y = GWAVE_data[idx];
			dy = GWAVE_DY_data[idx];
		} else {
			// we are in the s1/f1 portion
			uint32_t sx = (osc->x - osc->tp) * osc->k1;
			uint32_t idx = __USAT(sx >> SLOPE_DIV, GWAVE_BITS);
			y = -GWAVE_data[idx];
			dy = -GWAVE_DY_data[idx];
		}
		// TODO
		frac = 0.f;
		out[i] = osc->amp * (y + frac * dy);
		// step the phase
		osc->x += osc->xstep;
		osc->x &= (PHASE_MAX - 1);
	}
}

// gwave generation with amplitude modulation
void gwave_gen_am(struct gwave *osc, float *out, float *am, size_t n) {
	gwave_gen(osc, out, n);
	block_mul(out, am, n);
}

//-----------------------------------------------------------------------------

// Control the shape of the Goom wave.
// duty = duty cycle 0..1
// slope = slope 0..1
void gwave_shape(struct gwave *osc, float duty, float slope) {
  float s;
 	// This is where we transition from s0f0 to s1f1.
	duty = clamp(duty, 0.f, 1.f);
	osc->tp = TP_MIN + (uint32_t) ((float)(PHASE_MAX - (TP_MIN << 1)) * duty);
	// Work out the portion of s0f0/s1f1 that is sloped.
	slope = clamp(slope, 0.f, 1.f);
	s = S_MIN + (1.f - S_MIN) * slope;
	// scaling constant for s0, map the slope to the LUT.
	osc->k0 = (GWAVE_SIZE << SLOPE_DIV) / (uint32_t) ((float)osc->tp * s);
	// scaling constant for s1, map the slope to the LUT.
	osc->k1 = (GWAVE_SIZE << SLOPE_DIV) / (uint32_t) ((float)(PHASE_MAX - osc->tp) * s);
}

//-----------------------------------------------------------------------------

// Initialise a Goom wave.
void gwave_init(struct gwave *osc, float duty, float slope, float amp, float freq, float phase) {
	memset(osc, 0, sizeof(struct gwave));
	// amplitude
	osc->amp = amp;
	// frequency
	osc->freq = freq;
	osc->xstep = (uint32_t) (osc->freq * GWAVE_FSCALE);
	// phase
	osc->phase = fmodf(phase, TAU);
  // set the shape
  gwave_shape(osc, duty, slope);
}

//-----------------------------------------------------------------------------
