//-----------------------------------------------------------------------------
/*

Goom Waves

A Goom Wave is a wave shape with the following segments:

1) A rising cos -pi to 0 curve (s0)
2) A flat piece at the top (f0)
3) A falling cos 0 to pi curve (s1)
4) A flat piece at the bottom (f1)

Shape is controller by two parameters:
duty = split the total period between s0,f0 and s1,f1
slope = split s0f0 and s1f1 beween slope and flat.

*/
//-----------------------------------------------------------------------------

#include <string.h>
#include <math.h>

#include "ggm.h"

#define DEBUG
#include "logging.h"

//-----------------------------------------------------------------------------

// N bits to represent the phase
#define PHASE_BITS (24U)
#define PHASE_MAX (1U << PHASE_BITS)

// This limits how close the duty cyle can get to 0/100%.
// The transition point is between TP_MIN and PHASE_MAX - TP_MIN
#define TP_MIN (PHASE_MAX >> 6)

// Put a limit on how fast the slope can rise.
#define S_MIN 0.1f

#define DIV_BITS (20U)

// frequency to x scaling (xrange/fs)
#define GWAVE_FSCALE ((float)PHASE_MAX / AUDIO_FS)

//-----------------------------------------------------------------------------

// generated by ./scripts/lut.py
#define GOOM_TABLE_BITS (6U)
#define GOOM_TABLE_SIZE (1U << 6)
static const uint32_t GOOM_TABLE_data[GOOM_TABLE_SIZE] = {
	0xbf800000U, 0xbf7fae89U, 0xbf7eba56U, 0xbf7d2404U,
	0xbf7aec96U, 0xbf781573U, 0xbf74a06bU, 0xbf708fb2U,
	0xbf6be5ddU, 0xbf66a5e5U, 0xbf60d321U, 0xbf5a7145U,
	0xbf538462U, 0xbf4c10e0U, 0xbf441b7dU, 0xbf3ba94aU,
	0xbf32bfa6U, 0xbf29643eU, 0xbf1f9d07U, 0xbf15703aU,
	0xbf0ae450U, 0xbf000000U, 0xbee99471U, 0xbed29439U,
	0xbebb0dfbU, 0xbea310afU, 0xbe8aab9aU, 0xbe63dc87U,
	0xbe31d0d4U, 0xbdfea7eaU, 0xbd990c17U, 0xbccc3b73U,
	0x3ccc3b73U, 0x3d990c17U, 0x3dfea7eaU, 0x3e31d0d4U,
	0x3e63dc87U, 0x3e8aab9aU, 0x3ea310afU, 0x3ebb0dfbU,
	0x3ed29439U, 0x3ee99471U, 0x3f000000U, 0x3f0ae450U,
	0x3f15703aU, 0x3f1f9d07U, 0x3f29643eU, 0x3f32bfa6U,
	0x3f3ba94aU, 0x3f441b7dU, 0x3f4c10e0U, 0x3f538462U,
	0x3f5a7145U, 0x3f60d321U, 0x3f66a5e5U, 0x3f6be5ddU,
	0x3f708fb2U, 0x3f74a06bU, 0x3f781573U, 0x3f7aec96U,
	0x3f7d2404U, 0x3f7eba56U, 0x3f7fae89U, 0x3f800000U,
};

//-----------------------------------------------------------------------------

void gwave_gen(struct gwave *osc, float *out, size_t n) {
	unsigned int i;
	uint32_t idx;
	float y;

	for (i = 0; i < n; i++) {
		// what portion of the goom wave are we in?
		if (osc->x < osc->tp) {
			// we are in the s0/f0 portion
			idx = __USAT(osc->x * osc->k0 >> DIV_BITS, GOOM_TABLE_BITS);
			y = osc->table[idx];
		} else {
			// we are in the s1/f1 portion
			idx = __USAT((osc->x - osc->tp) * osc->k1 >> DIV_BITS, GOOM_TABLE_BITS);
			y = -osc->table[idx];
		}
		out[i] = osc->amp * y;
		// step the phase
		osc->x += osc->xstep;
		osc->x &= (PHASE_MAX - 1);
	}
}

// gwave generation with amplitude modulation
void gwave_gen_am(struct gwave *osc, float *out, float *am, size_t n) {
	gwave_gen(osc, out, n);
	block_mul(out, am, n);
}

//-----------------------------------------------------------------------------

// Initialise a Goom wave.
// duty = duty cycle [0..1]
// slope = slope [0..1]
void gwave_init(struct gwave *osc, float duty, float slope, float amp, float freq, float phase) {
	float s;

	memset(osc, 0, sizeof(struct gwave));

	// amplitude
	osc->amp = amp;

	// frequency
	osc->freq = freq;
	osc->xstep = (uint32_t) (osc->freq * GWAVE_FSCALE);

	// phase
	osc->phase = fmodf(phase, TAU);

	// setup the table
	osc->table = (float *)GOOM_TABLE_data;

	// This is where we transition from s0f0 to s1f1.
	duty = clamp(duty, 0.f, 1.f);
	osc->tp = TP_MIN + (uint32_t) ((float)(PHASE_MAX - (TP_MIN << 1)) * duty);

	// Work out the portion of s0f0/s1f1 that is sloped.
	slope = clamp(slope, 0.f, 1.f);
	s = S_MIN + (1.f - S_MIN) * slope;

	// scaling constant for s0, map the slope to the LUT.
	osc->k0 = (GOOM_TABLE_SIZE << DIV_BITS) / (uint32_t) ((float)osc->tp * s);

	// scaling constant for s1, map the slope to the LUT.
	osc->k1 = (GOOM_TABLE_SIZE << DIV_BITS) / (uint32_t) ((float)(PHASE_MAX - osc->tp) * s);

	DBG("tp %08x k0 %08x k1 %08x\r\n", osc->tp, osc->k0, osc->k1);
}

//-----------------------------------------------------------------------------
